#***************************************************************************
#                                   Reps
#       Copyright (C) 2005 Peter Webb 
#       Copyright (C) 2006 Peter Webb, Robert Hank, Bryan Simpkins 
#       Copyright (C) 2007 Peter Webb, Dan Christensen, Brad Froehle
#       Copyright (C) 2020 Peter Webb, Moriah Elkin
#       Copyright (C) 2022 Juan David Ferreira
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#
#  The overall structure of the reps package was designed and most of it
#  written by Peter Webb <webb@math.umn.edu>, who is also the maintainer. 
#  Contributions were made by
#  Dan Christensen, Roland Loetscher, Robert Hank, Bryan Simpkins,
#  Brad Froehle and others.
#***************************************************************************

##############################################################################
##
## FixedQuotient(rep) returns a basis for augmentation ideal . module.
## Handles trivial groups and zero-dimensional reps.
##
##############################################################################

InstallGlobalFunction( FixedQuotient, function(rep)
    local onemat, v;
    if IsBound(rep.fixedQuotient) then
	    return rep.fixedQuotient;
	fi;
    onemat:=SafeIdentityMat(rep.dimension, rep.field);
    v:=Concatenation(List(rep.genimages, g->g - onemat));
    v:=SafeBaseMat(v);
    rep.fixedQuotient:=v;
    return v;
end );

##############################################################################
##
## SubFixedQuotient(rep, list of vecs)
## returns a basis for augmentation ideal . submodule spanned by the vecs.
## The span of the vecs must be a submodule, and this is not checked.
## Handles trivial groups, zero-dimensional reps and empty `vecs`.
##
##############################################################################

InstallGlobalFunction( SubFixedQuotient, function(rep, vecs)
    local onemat, v, genimages, dim, l;
    dim:=rep.dimension;
    onemat:=SafeIdentityMat(dim, rep.field);
    genimages := rep.genimages;
    l:=List(genimages, g -> SafeMatrixMult( vecs, g - onemat, dim ) );
    v:=Concatenation(l);
    return SafeBaseMat(v);
end );

##########################################################
##
## BrauerTraceImage(representation, p-subgroup of rep.group) returns a list
## of vectors that is a basis for the sum of the images of traces from proper
## subgroups of the p-group.  Written by Peter Webb June 2016.
##
##########################################################

InstallGlobalFunction( BrauerTraceImage, function(rep,p)
   local resp, resh, maxsub, image, h, M;
   resp:=RestrictedRep(rep.group,p,rep);
   maxsub:=MaximalSubgroups(p);
   image:=[];
   for h in maxsub do
   	M:=RelativeTrace(p,h,resp);
	resh:=RestrictedRep(resp.group,h,resp);
	Append(image,SafeMatrixMult(FixedPoints@(resh),M,rep.dimension));
   od;
   return(SafeBaseMat(image));
end );

##############################################################################
##
## Spin(rep, veclist) returns a basis for the submodule generated by the
## vectors in veclist, which must be a list of vectors.
##
## GroupSpin is called by Spin(rep, veclist) when rep is a
## group representation.
## 
##############################################################################

InstallGlobalFunction( Spin, function(rep,veclist)
    return rep.operations.Spin(rep,veclist);
end );

InstallGlobalFunction( GroupSpin, function(rep,veclist)
    local basis, oldlength, newvecs, g,v;
    basis:=List(SafeBaseMat(veclist));
    oldlength:=Length(basis)-1;
    while Length(basis) > oldlength do
        oldlength:=Length(basis);
        newvecs:=[];
        for g in rep.genimages do
            for v in basis do
                Add(newvecs, v*g);
            od;
        od;
        Append(basis,newvecs);
        basis:=List(SafeBaseMat(basis));
    od;
    return basis;
end );

##############################################################################
##
## CoSpin(rep, veclist) . . .returns a basis for the largest submodule
## contained in the vector subspace spanned by veclist.
##
## GroupCoSpin is called by CoSpin(rep, veclist) when rep is a
## group representation.
##
##############################################################################

InstallGlobalFunction( CoSpin, function(rep,veclist)
    return rep.operations.CoSpin(rep,veclist);
end );

InstallGlobalFunction( GroupCoSpin, function(rep,veclist)
    local u, fakerep;
    if Length(veclist)=0 then return(veclist); fi;
    u:=NullspaceMat(TransposedMat(veclist));
    if Length(u)=0 then
        return(IdentityMat(rep.dimension,rep.field));
    fi;
    fakerep:=ShallowCopy(rep);
    fakerep.genimages:=List(fakerep.genimages,TransposedMat);
    #Warning: fakerep is not a representation, because the genimages represent
    #the opposite group.
    u := Spin(fakerep,u);
    u := NullspaceMat(TransposedMat(u));
    return(List(u,x->x));
end );

##############################################################################
##
## SumOfImages(rep,rep) . . returns a basis for the sum of images of all 
## module homomorphisms A -> B
##
## GroupSumOfImages is called by SumOfImages(rep,rep) when rep is a
## group representation.
##
## Updated by Peter Webb Sep 11, 2007
##
##############################################################################

InstallGlobalFunction( SumOfImages, function(M,N)
    return M.operations.SumOfImages(M,N);
end );

InstallGlobalFunction( GroupSumOfImages, function(g,h)
    return SafeBaseMat(Concatenation(HomBasis(g,h)));
end );

##############################################################################
##
## KernelIntersection(rep,rep) . . returns a basis for the intersection of the kernels of all 
## module homomorphisms A -> B
## Created by Peter Webb May 8, 2019. Corrected April 18, 2020.
## This uses a version of SafeNullspaceMat with two arguments, the second being the field.
##
##############################################################################

InstallGlobalFunction( KernelIntersection, function(g,h)
    local transposedmats;
    transposedmats:=List(HomBasis(g,h), TransposedMat);
    if Length(transposedmats)=0 then 
        return(SafeIdentityMat(g.dimension, g.field));
    else
        return SafeNullspaceMat(TransposedMat(Concatenation(transposedmats)),g.field);
    fi;
end );

##############################################################################
##
## Decompose(rep) . . returns a list of bases of direct summands of rep which
## are probably indecomposable.
##
## DecomposeGroupRep is called by Decompose(rep) when rep
## is a group representation.
##
## This code was written by Bryan Simpkins and Robert Hank, University of
## Minnesota, April 2006.
## It was modified by Dan Christensen and Peter Webb August 2007 so that indecomposable
## representations are only checked once (before they were checked twice),
## so as to use space more economically, and so that the result is stored
## in rep.summands.
##
##############################################################################

InstallGlobalFunction( Decompose, function(rep)
    return rep.operations.Decompose(rep);
end );

InstallGlobalFunction( DecomposeGroupRep, function(rep)
	local summands, result, q;
	if IsBound(rep.summands) then return(rep.summands);
	fi;
	summands := [IdentityMat(rep.dimension,rep.field)];
	q := 1;
	# We maintain the following invariants:
	# - summands is a list of lists of vectors; the union of these
	#   lists forms a basis for rep.field^(rep.dimension).
        # - the summands at positions < q appear to be indecomposable;
	#   those at positions >= q haven't been investigated completely.
	while IsBound(summands[q]) do;
		result := DecomposeSubmodule(rep, summands[q]);
		if Length(result) = 2 then
			summands[q] := result[1];
			Add(summands, result[2]);
		else
			q := q + 1;
		fi;
	od;
	rep.summands:=summands;
	return summands;
end );

##############################################################################
##
## DecomposeSubmodule(repn, basis) . . probably returns a list of two bases 
## for summands of 
## the submodule of repn spanned by basis, if the module is decomposable, and
## if the module is indecomposable it returns a list whose only element is the
## given basis.
##
## GroupDecomposeSubmodule is called by DecomposeSubmodule(repn, basis) when repn
## is a group representation.
##
## This code was written by Bryan Simpkins and Robert Hank, University of
## Minnesota, April 2006. A related approach was taken by Michael Smith in
## code written in 1993.
## It was tidied up by Dan Christensen, University of Western Ontario, Aug 2007.
## In July 2016 Craig Corsi, University of Minnesota, made a change so that
## decompositions over fields larger than the field of definition of the 
## representation are found.
##
##############################################################################

InstallGlobalFunction( DecomposeSubmodule, function(M, basis)
    return M.operations.DecomposeSubmodule(M, basis);
end );

InstallGlobalFunction( GroupDecomposeSubmodule, function(repn, basis)
	local newrep, initlist, a, kernel, image, b, d, n, z;
	if Length(basis) <= 1 then return [basis]; fi;
	newrep := SubmoduleRep(repn, basis);
	z:=PrimitiveElement(repn.field);
	initlist := HomBasis(newrep,newrep);
	Add(initlist, 0 * initlist[1]);
	b := Length(initlist);
	while b > 0 do;
		d := b - 1;
		while d > 0 do;
			a := z*initlist[b] + initlist[d];
			n := 1;
			while n < Length(basis) do;
				a:= a*a;
				n:= 2*n;
			od;
			kernel := NullspaceMat(a);
			if not(Length(kernel) = 0 or Length(kernel) = Length(basis)) then
				image  := BaseMat(a);
				return [kernel * basis, image * basis];
			fi;
			d := d - 1;
		od;
		b := b - 1;
	od;
	return [basis];
end );

##############################################################################
##
## ProjectiveDecomposition(rep) returns a list of two bases, for a submodule
## which is projective, and for a submodule with probably no non-zero projective summands,
## whose direct sum is the whole representation. 
##
##############################################################################

InstallGlobalFunction( ProjectiveDecomposition, function(M)
    local comps, comp, pfbasis, pbasis;
    comps:=Decompose(M);
    pfbasis:=[];
    pbasis:=[];
    for comp in comps do
        if not IsProjectiveRep(SubmoduleRep(M, comp)) then
            Append(pfbasis, comp);
        else Append(pbasis, comp);
        fi;
    od;
    return ([pbasis,pfbasis]);
end );

##############################################################################
##
## ProjectiveSummand(rep) returns a basis for a maximal projective direct summand of
## rep. It is only guaranteed to work when the group is a p-group in characteristic p.
## In other cases it may give a correct answer, and if it does not then an error
## message is returned. It does not use Decompose. Written by Peter Webb February 2020.
##
##############################################################################


InstallGlobalFunction( ProjectiveSummand, function(rep)
    local n, resrep, vectors, sub, char, SySG, IdMat;
    char := Characteristic(rep.field);
    SySG:=SylowSubgroup(rep.group,char);
    resrep := RestrictedRep( rep.group, SySG, rep);
    n:=NormRep(resrep);
    if Length(n)=0 then
        return(rep);
    fi;
    IdMat:=IdentityMat(rep.dimension, rep.field);
    vectors:=BaseSteinitzVectors( IdMat, NullspaceMat( n ) );
    sub := Spin( rep, vectors.factorspace );
    if IsProjectiveRep(SubmoduleRep(rep,sub))=false then
        Error("The routine produced a basis called sub, for a submodule that is too big and not projective. It is only guaranteed to work for p-groups.");
        return;
    fi;
    return(sub);
end );

##############################################################################
##
## ProperSubmodule(rep) calls the meataxe command MTX.ProperSubmoduleBasis
## and returns a basis for a proper submodule, or [] if there is none.
##
##############################################################################

InstallGlobalFunction( ProperSubmodule, function(rep)
    local basis;
    if rep.dimension=0 then
        return([]);
    fi;
    basis:=(MTX.ProperSubmoduleBasis(RepToMeataxeModule(rep)));
    if basis=fail then
        return([]); fi;
    return(basis);
end );

InstallGlobalFunction( RadicalRep, function(rep)
    if rep.dimension=0 then return([]); fi;
    return(MTX.BasisRadical(RepToMeataxeModule(rep)));
end );

InstallGlobalFunction( SocleRep, function(rep)
    if rep.dimension=0 then return([]); fi;
    return(MTX.BasisSocle(RepToMeataxeModule(rep)));
end );


#########################################################
##
## RadicalSeries(rep) returns a list with two entries [bases, reps] where 
## bases is a list of bases of the successive powers of the radical
## rep = rad^0(rep), rad^1(rep), ...
## in descending order. The last term in the list is the empty list.
## reps is a list of the representations on the radical quotients
## rep/rad^1(rep), rad^1(rep)/rad^2(rep). ...
## all of which are semisimple. The last term is the last nonzero 
## representation, and so the list is one shorter than bases.
## Written by Peter Webb July 2016.
##
#########################################################

InstallGlobalFunction( RadicalSeries, function(rep)
    local rad, i, submod, submodrad, layer;
    rad:=[]; layer:=[];
    rad[1]:=SafeIdentityMat(rep.dimension,rep.field);
    i:=1;
    while Length(rad[i]) > 0 do
        i:=i+1;
        submod:=SubmoduleRep(rep,rad[i-1]);
        submodrad:=RadicalRep(submod);
        rad[i]:=SafeMatrixMult(submodrad,rad[i-1],submod.dimension);
        layer[i-1]:=QuotientRep(submod,submodrad);
    od;
    return([rad,layer]);
end );

#########################################################
##
## SocleSeries(rep) returns a list with two entries [bases, reps] where 
## bases is a list of bases of the higher socles
## rep = soc^t(rep), soc^(t-1)(rep), ...
## in DESCENDING order. The last term in the list is the empty list.
## reps is a list of the representations on the socle quotients
## rep/soc^(t-1)(rep), soc^(t-1)(rep)/soc^(t-2)(rep). ...
## all of which are semisimple. The last term is the last nonzero 
## representation, and so the list is one shorter than bases.
## Written by Peter Webb July 2016.
##
#########################################################

InstallGlobalFunction( SocleSeries, function(rep)
    local radseries, n, temp, socseries, i, F, dim;
    radseries:=RadicalSeries(DualRep(rep));
    socseries:=[];
    socseries[1]:=[];
    socseries[2]:=[];
    temp:=[];
    dim:=rep.dimension;
    F:=rep.field;
    temp[1]:=List(radseries[1],y->SocleNullspaceMat(TransposedMat(y), dim, F));
    temp[2]:=List(radseries[2],DualRep);
    n:=Length(radseries[2]);
    for i in [1..n+1] do
        socseries[1][i]:=temp[1][n+2-i];
    od;
    for i in [1..n] do
        socseries[2][i]:=temp[2][n+1-i];
    od;
    return(socseries);
end );

#########################################################
## ButterflyFactors(rep, descending filtration, descending filtration) 
## returns a matrix whose entries are the representations that appear as
## sections in Zassenhaus' Butterfly Lemma.
## Each descending filtration is a list of bases of submodules of rep, forming
## a descending chain. The representations in the output are the factors in
## a common refinement of the two filtrations, fand their position in the 
## refinement is indicated by their position in the matrix.
## Written by Peter Webb July 2016
#########################################################

InstallGlobalFunction( ButterflyFactors, function(rep,L1,L2)
    local factors, i, j, vecsa, vecsb;
    factors:=[];
    for i in [1..Length(L1)-1] do
        factors[i]:=[];
        for j in [1..Length(L2)-1] do
            vecsa:=SumIntersectionMat(L1[i],L2[j])[2];
            vecsb:=SumIntersectionMat(SumIntersectionMat(L1[i+1],L2[j])[2],
            SumIntersectionMat(L1[i],L2[j+1])[2])[1];
            factors[i][j]:=SectionRep(rep,vecsa,vecsb);
        od;
    od;
    return(factors);
end );

InstallGlobalFunction( BasesCompositionSeriesRep, function(rep)
    if rep.dimension=0 then return([[]]); fi;
    return(MTX.BasesCompositionSeries((RepToMeataxeModule(rep))));
end );

##############################################################################
##
## MatrixOfElement(rep,group element) returns the matrix which represents
## the group element.
##
##############################################################################

InstallGlobalFunction( MatrixOfElement, function(rep,g)
    local newrep, newg, mat, s, temp;
    MakeIsoToPermGroup(rep);
    newrep:=rec(
        group:=rep.permgroup,
        genimages:=rep.genimages,
        field:=rep.field,
        dimension:=rep.dimension,
        isRepresentation:=true,
        operations:=GroupRepOps
    );
    newg:=Image(rep.isotopermgroup,g);
    mat:=IdentityMat(rep.dimension,rep.field);
    while Size(newrep.group)>1 do
        s:=SmallestMovedPoint(newrep.group);
        temp:=MatsOfCosetReps(newrep);
        newrep:=temp[1];
        mat:=temp[2][s^newg]*mat;
        newg:=newg*temp[3][s^newg]^-1;
    od;
    return(mat);
end );

##############################################################################
##
## MatricesOfElements(rep,list of group elements) returns the list of matrices 
## which represent the group elements.
##
##############################################################################

InstallGlobalFunction( MatricesOfElements, function(rep, l)
    local newrep, newl, matlist, s, temp, x, n;
    MakeIsoToPermGroup(rep);
    newrep:=rec(
        group:=rep.permgroup,
        genimages:=rep.genimages,
        field:=rep.field,
        dimension:=rep.dimension,
        isRepresentation:=true,
        operations:=GroupRepOps
    );
    n:=Length(l);
    newl:=List(l, x->Image(rep.isotopermgroup,x));
    matlist:=List(l,x->IdentityMat(rep.dimension,rep.field));
    while Size(newrep.group)>1 do
        s:=SmallestMovedPoint(newrep.group);
        temp:=MatsOfCosetReps(newrep);
        newrep:=temp[1];
        matlist:=List([1..n], x->temp[2][s^newl[x]]*matlist[x]);
        newl:=List(newl,x->x*temp[3][s^x]^-1);
    od;
    return(matlist);
end );

# --------------------------------------------------------------------------- #
# --------------------------------------------------------------------------- #
# --------------------------------------------------------------------------- #
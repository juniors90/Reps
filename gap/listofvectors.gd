#***************************************************************************
#                                   Reps
#       Copyright (C) 2005 Peter Webb 
#       Copyright (C) 2006 Peter Webb, Robert Hank, Bryan Simpkins 
#       Copyright (C) 2007 Peter Webb, Dan Christensen, Brad Froehle
#       Copyright (C) 2020 Peter Webb, Moriah Elkin
#       Copyright (C) 2022 Juan David Ferreira
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#
#  The overall structure of the reps package was designed and most of it
#  written by Peter Webb <webb@math.umn.edu>, who is also the maintainer. 
#  Contributions were made by
#  Dan Christensen, Roland Loetscher, Robert Hank, Bryan Simpkins,
#  Brad Froehle and others.
#***************************************************************************

#! Commands that return lists of vectors:
#! FixedPoints(rep). . returns a list of vectors which form a basis for the fixed points of rep.

#! FixedQuotient(rep). . returns a list of vectors which form a basis for the augmentation ideal times rep.

#! SubFixedQuotient(rep, list of vectors). . returns a list of vectors which form a basis for the augmentation ideal times the submodule spanned by the list of vectors.

#! BrauerTraceImage(rep, p-subgroup of rep.group). .returns a list of vectors that forms a basis for the sum of images of trace maps from fixed points of proper subgroups of the p-subgroup.

#! Spin(rep, list of vectors) . . returns a basis for the submodule generated by the vectors in the list
# GroupSpin

#! CoSpin(rep, list of vectors) . . .returns a basis for the largest submodule contained in the vector subspace spanned by the vectors in the list.
#! GroupCoSpin

#! SumOfImages(rep,rep). .returns a basis for the sum of images of all module homomorphisms A -> B
#! GroupSumOfImages

#! KernelIntersection(rep,rep) . . returns a basis for the intersection of the kernels of all module homomorphisms A -> B.

#! Decompose(rep) . . returns a list of bases of summands in a direct sum decomposition of rep. The summands are probably indecomposable. This code was written by Bryan Simpkins and Robert Hank. Warning: only summands which are defined over the field generated by the matrix entries in rep are found. It is possible to modify the code to find decompositions over extension fields, but this has not been done.

#! DecomposeSubmodule(rep, list of vectors) . . Returns a list of two bases for summands of the submodule spanned by the list of vectors (it does not check that the span is invariant) if the submodule is decomposable. If the submodule is indecomposable it returns a list whose only element is the given basis. A probabilistic algorithm is used. The routine is called by Decompose.

#! ProjectiveDecomposition(rep). .returns a list of two bases, for a submodule which is projective, and for a submodule with probably no non-zero projective summands, whose direct sum is the whole representation.

#! ProjectiveSummand(rep). .returns a basis for a maximal projective direct summand of rep. It is only guaranteed to work when the group is a p-group in characteristic p. In other cases it may give a correct answer, and if it does not then an error message is returned. It does not use Decompose.

#! ProperSubmodule(rep). . returns a list of vectors which form a basis for a proper submodule of rep if there is one, and otherwise returns the empty list []. This function calls the meataxe routine MTX.ProperSubmoduleBasis which is already implemented in GAP.

#! RadicalRep(rep). . returns a list of vectors which form a basis for the radical of rep. This function calls the meataxe routine MTX.BasisRadical which is already implemented in GAP.

#! SocleRep(rep). . returns a list of vectors which form a basis for the socle of rep. This function calls the meataxe routine MTX.BasisSocle which is already implemented in GAP.

#! RadicalSeries(rep) returns a list with two entries [bases, reps] where bases is a list of bases of the successive powers of the radical rep = rad^0(rep), rad^1(rep), ... in descending order. The last term in the list is the empty list. reps is a list of the representations on the radical quotients rep/rad^1(rep), rad^1(rep)/rad^2(rep). ... all of which are semisimple. The last term is the last nonzero representation, and so the list is one shorter than bases.

#! SocleSeries(rep). .returns a list with two entries [bases, reps] where bases is a list of bases of the higher socles rep = soc^t(rep), soc^(t-1)(rep), ... in DESCENDING order. The last term in the list is the empty list. reps is a list of the representations on the socle quotients rep/soc^(t-1)(rep), soc^(t-1)(rep)/soc^(t-2)(rep). ... all of which are semisimple. The last term is the last nonzero representation, and so the list is one shorter than bases.

#! ButterflyFactors(rep, descending filtration, descending filtration) returns a matrix whose entries are the representations that appear as sections in Zassenhaus' Butterfly Lemma. Each descending filtration is a list of bases of submodules of rep, forming a descending chain. The representations in the output are the factors in a common refinement of the two filtrations, and their position in the refinement is indicated by their position in the matrix.

#! BasesCompositionSeriesRep(rep). . returns a list of bases of submodules which form a composition series of rep. This function calls the meataxe routine MTX.BasesCompositionSeries which is already implemented in GAP.

#! MatrixOfElement(rep, group element). . returns the matrix which represents the group element.

#! MatricesOfElements(rep, list of group elements). . returns the list of matrices which represent the group elements.